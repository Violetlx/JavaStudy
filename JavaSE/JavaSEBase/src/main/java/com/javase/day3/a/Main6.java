package com.javase.day3.a;

import com.javase.day3.entity.Animal;
import com.javase.day3.entity.Person;

/**
 * 静态变量和静态方法
 * @author lixuan
 * @Date 2024/5/29 11:05
 */
public class Main6 {
    public static void main(String[] args) {
        /*
         * 我们可以通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作都是同一个
         * 目标，也就是说，对象再多，也只有这一个静态的变量或方法
         * 一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。
         */

        //加上static静态，表示这个变量或方法属于这个类了，而不是某一个对象
        Person.info = "我是静态变量";
        System.out.println(Person.info);

        System.out.println("--------------------------");

        //静态方法
        test();

        System.out.println("--------------------------");

        /*
         * 静态变量时在什么时候初始化的呢？
         * 我们在一开始介绍了，我们实际上时将 .class 文件丢给JVM去执行，而每一个 .class 文件其实就是我们编写的一个类，我们在
         * Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载(优化) 一般遇到以下的情况才会去加载：
         * 1、访问类的静态变量，或者为静态变量赋值
         * 2、new 创建类的实例(隐式加载)
         * 3、调用类的静态方法
         * 4、子类初始化时
         *
         * 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载
         */

        //测试
        Animal animal = new Animal();

        /*
         * 我是静态变量初始化
         * 我是静态代码块
         * 我是成员变量初始化
         * 我是普通代码块
         * 我是构造方法
         */

        //可以看到，确实是静态内容在对象构造之前就完成了初始化，实际上就是类初始化时完成的

        System.out.println("--------------------------");

        //当然，如果我们直接访问类的静态变量
        System.out.println(Person.info);

        //那么此时同样会使得类初始化，进行加载

        //可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也就不会被初始化了


    }

    static void test() {
        System.out.println("我是静态方法");
    }
}
