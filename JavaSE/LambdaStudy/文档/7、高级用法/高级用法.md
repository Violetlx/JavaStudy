### 7 高级用法

#### 基本数据类型优化

​     我们之前用到的很多Stream的方法由于都使用到了泛型，所以涉及到的参数和返回值都是引用数据类型。

​     即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引用的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很小，但是在大量的数据不断重复装箱和拆箱的时候，你就不能无视这个时间了。

​     所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。

​     例如：

​     mapToInt、mapToLong、mapToDouble、flatMapToInt、flatMapToDouble等

```java
/**
 * 1、高级用法的使用
 */
@Test
void lambdaHigher() {
    List<Author> authors = getAuthors();

    authors.stream()
            .distinct()
            .map(author -> author.getAge())
            .map(age -> age+10)
            .filter(age -> age>18)
            .map(age -> age+2)
            .forEach(System.out::println);

    System.out.println("-----------------------");

    authors.stream()
            .distinct()
            .mapToInt(new ToIntFunction<Author>() {
                @Override
                public int applyAsInt(Author author) {
                    return author.getAge();
                }
            })
            .map(age -> age+10)
            .filter(age -> age>18)
            .map(age -> age+2)
            .forEach(System.out::println);

    System.out.println("-----------------------");

    //优化 mapToInt 避免了频繁的装箱和拆箱的过程
    authors.stream()
            .distinct()
            .mapToInt(Author::getAge)
            .map(age -> age+10)
            .filter(age->age>18)
            .map(age -> age+2)
            .forEach(System.out::println);
}
```



#### 并行流

​    当流中有大量元素时，我们可以使用并行流去提高操作的效率，其实并行流就是把任务分配给多个线程去完成。如果我们自己去用代码实现的话其实是非常复杂的，并且要求你对并发编程有足够的理解认识，而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮助我们实现，从而提高效率。

```java
/**
 * 2、高级用法的使用
 */
@Test
void lambdaHigher2() {
    Stream.of(1,2,3,4,5,6,7,8,9,10)
           .filter(i -> i%2==0)
           .map(i -> i*i)
           .forEach(System.out::println);

    System.out.println("-----------------------");

    Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    Integer sum = stream.parallel()//并行流
            .filter(num -> num > 5)
            .reduce(Integer::sum)
            .get();
    System.out.println(sum);

    System.out.println("-----------------------");

    Stream<Integer> stream1 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    stream1.parallel()
            .peek(new Consumer<Integer>() {//peek 不会改变流的状态
                @Override
                public void accept(Integer integer) {
                    System.out.println(integer+Thread.currentThread().getName());//打印线程名 看你在那个线程里面
                }
            })
            .filter(num -> num > 5)
            .reduce(Integer::sum)
            .get();
}
```

也可以通过parallelStream直接获取并行流

```java
/**
 * 3、高级用法的使用
 */
@Test
void lambdaHigher3() {
    List<Author> authors = getAuthors();
    authors.parallelStream()
            .distinct()
            .mapToInt(Author::getAge)
            .map(age -> age+10)
            .filter(age -> age>18)
            .map(age -> age+2)
            .forEach(System.out::println);
}
```